// Copyright (c) 2017 Computer Vision Center (CVC) at the Universitat Autonoma
// de Barcelona (UAB).
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

#pragma once

#include "carla/Memory.h"
#include "carla/sensor/RawData.h"

#include <cstdint>
#include <cstring>
#include <iostream>
#include <math.h>

namespace carla {
namespace sensor {

  class SensorData;

namespace s11n {

  /// Serializes image buffers generated by camera sensors.
  class LightCodeSerializer {
  public:

#pragma pack(push, 1)
    struct ImageHeader {
      uint32_t width;
      uint32_t height;
      float fov_angle;
      float range;
    };
#pragma pack(pop)

    constexpr static auto header_offset = sizeof(ImageHeader);

    static const ImageHeader &DeserializeHeader(const RawData &data) {
      return *reinterpret_cast<const ImageHeader *>(data.begin());
    }

    template <typename Sensor>
    static Buffer Serialize(const Sensor &sensor, Buffer &&bitmap);

    static SharedPtr<SensorData> Deserialize(RawData &&data);
  };

  template <typename Sensor>
  inline Buffer LightCodeSerializer::Serialize(const Sensor &sensor, Buffer &&bitmap) {
    DEBUG_ASSERT(bitmap.size() > sizeof(ImageHeader));
    
    ImageHeader header = {
      sensor.GetImageWidth(),
      sensor.GetImageHeight(),
      sensor.GetFOVAngle(),
      sensor.GetRange(),
    };

    float fieldOfView = header.fov_angle;
    int hResolution = static_cast<int>(header.width);
    int vResolution = static_cast<int>(header.height);
    
    uint distancesArraySize = static_cast<uint>(hResolution * vResolution);
    float* distances = new float[distancesArraySize] ();
    float* coordinates = new float[distancesArraySize * 3] ();
    Buffer outBuffer{distancesArraySize * 3 * sizeof(float) + sizeof(header)};
    
    // Calculating pixel distances based on the raw bgra image
    int currentPosition = 0;
    for (int pixel = sizeof(header); pixel < static_cast<int>(bitmap.size()); pixel += 4) {
      int b = static_cast<int>(bitmap.data()[pixel]);
      int g = static_cast<int>(bitmap.data()[pixel + 1]);
      int r = static_cast<int>(bitmap.data()[pixel + 2]);
      float pixelDistance = 1000 * (static_cast<float>(r + g * 256 + b * 256 * 256) / (256 * 256 * 256 - 1));

      // Deleting all points that are further away than camera can get returns
      if (pixelDistance <= header.range) {
        distances[currentPosition] = pixelDistance;
      } else {
        distances[currentPosition] = std::numeric_limits<float>::quiet_NaN();
      }
      currentPosition++;
    }

    // Calculate point cloud based on distances, camera parameters and pixel positions. 
    // Coordinates follow left hand rule: X-forward, Y-right, z-up.
    float angularResolution = fieldOfView / hResolution;
    int hHalfPixelCount = hResolution / 2;
    int vHalfPixelCount = vResolution / 2;

    int column = 0;
    int row = 0;
    for (int i = 0; i < static_cast<int>(distancesArraySize); i++) {
      float x_coordinate = distances[i];
      float y_coordinate;
      float z_coordinate;
      column = i % hResolution;

      // Finding y-coordinates
      y_coordinate = x_coordinate / static_cast<float>(std::tan( ( 90 - std::abs( hHalfPixelCount - column - 0.5) * angularResolution )  * M_PI / 180));
      y_coordinate = (column < hHalfPixelCount) ? -y_coordinate : y_coordinate;

      // Finding z-coordinates
      z_coordinate = x_coordinate / static_cast<float>(std::tan( ( 90 - std::abs( vHalfPixelCount - row - 0.5) * angularResolution ) * M_PI / 180));
      z_coordinate = (row >= vHalfPixelCount) ? -z_coordinate : z_coordinate;
      
      row = (column == (hResolution - 1)) ? row + 1 : row;

      coordinates[3 * i] = x_coordinate;
      coordinates[3 * i + 1] = y_coordinate;
      coordinates[3 * i + 2] = z_coordinate;
    }

    std::memcpy(outBuffer.data(), reinterpret_cast<const void *>(&header), sizeof(header));
    std::memcpy(outBuffer.data() + sizeof(header), coordinates, sizeof(float) * distancesArraySize * 3);

    delete[] distances;
    delete[] coordinates;

    return outBuffer;
  }

} // namespace s11n
} // namespace sensor
} // namespace carla
